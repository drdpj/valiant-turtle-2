;************************************************************************
;
;   ir_uart.pio
;
;   Valiant Turtle 2 Communicator - Raspberry Pi Pico W Firmware
;   Copyright (C) 2024 Simon Inns
;
;   This file is part of Valiant Turtle 2
;
;   This is free software: you can redistribute it and/or
;   modify it under the terms of the GNU General Public License as
;   published by the Free Software Foundation, either version 3 of the
;   License, or (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
;
;   You should have received a copy of the GNU General Public License
;   along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
;   Email: simon.inns@gmail.com
;
;************************************************************************

.pio_version 0

.program ir_uart

    pull
    set x, 10                ; Get ready for the bit loop (8 bits + 3 parity)

leadin:
    set pins, 0b1       [ 4] ; Output pin high for 5 clocks
    set pins, 0b0            ; 
    out y, 2            [31] ; Shift 2 bits from OSR into Y wait 31
    jmp !y bitloop           ; IF Y == 0 THEN jump to longdelay (35uS leadin)
    nop                 [24] ; wait another 20 cycles (60 uS leadin)

bitloop:
    out y, 2                 ; Shift in 2 bits from the OSR into y
    set pins, 0b1       [ 4] ; Output pin high for 5 clocks
    set pins, 0b0
    nop                 [23]
    nop                 [20] ; 50 uS (50)
    jmp y-- delay1
    jmp bitdone

delay1:
    nop                 [23] ; 25 uS (75)
    jmp y-- delay2
    jmp bitdone

delay2:
    nop                 [25] ; 25 us (100)

bitdone:
    jmp x-- bitloop


% c-sdk {
static inline void ir_uart_program_init(PIO pio, uint sm, uint offset, uint gpio_pin) {

    pio_sm_config c = ir_uart_program_get_default_config(offset);

    // This is used if the PIO is using the "set" command to output to the pin
    sm_config_set_set_pins(&c, gpio_pin, 1);

    // We only need TX, so get an 8-deep FIFO! - DO WE NEED THIS?
    //sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    // Set the clock divider to /125
    sm_config_set_clkdiv(&c, 125);

    // // SM transmits 1 bit per 8 execution cycles.
    // float div = (float)clock_get_hz(clk_sys) / (8 * baud);
    // sm_config_set_clkdiv(&c, div);

    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, gpio_pin);

    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, gpio_pin, 2, true);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);

    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}